---
title: "UsageGuide"
author: "FR"
date: "07.09.2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The 'batchtools'-package and its usage in IDE+A
## What does the package do?
Let's say you have

* algorithms (a1,a2, ...,an)
* algorithm settings (s1, ...)

You want to test and compare them on some functions:

* functions (f1, ...)

The 'batchtools' package can do that in a nicely organised way and fully automatic.

You want to do it **automatically on a cluster**? Even better.

### Example 1

```{r echo=TRUE, results='hide', message=FALSE}
require(ideaBatch)

## Create an Experiment Registry with a Dir-Name and a Sub-Directory for each test.
reg <- ideaMakeRegistry("Seminar","Test1") 

## Add Objective Functions
addProblem("Rosen2D", of_smoofByName("Rosenbrock",2))
addProblem("Rastr2D", of_smoofByName("Rastrigin",2))
    
## Add Algorithms
addAlgorithm("optimLHD", algorithm_SpotOptimByName("optimLHD", c(-5,-5),c(5,5),
                                                  control = list(funEvals = 100)))
addAlgorithm("cmaesCMAES",algorithm_CMAES(c(-5,-5),c(5,5), control = list("maxit" = 100)))
    
## Build Experiments
addExperiments(prob.designs = list("Rosen2D" = data.frame(),
                                    "Rastr2D" = data.frame()),
               repls = 1)
```

### Show a summary - which Experiments are run?

```{R}
summarizeExperiments()
```

### Run your experiments

```{R, message=FALSE}
# ideaSubmitJobs()
# ideaSubmitJobs(ids = findNotSubmitted())
# 
ideaSubmitJobs(ids= findExperiments())
```

The submitJobs command submits Experiments to the cluster. It is possible to submit all defined Experiments, only specific ones, or filter for a certain group of experiments like: notSubmitted, notFinished, notStarted, aborted etc.

### Results
Experiment results will be nicely kept. As they share the same structure every time, general postprocessing functions can be defined and reused / shared in the team.

```{R}
results <- reduceResultsList()
df <- generateResultDF(results)
problems <- unique(df$problemName)
for (p in problems) {
    graph <- anyTimePerformancePlot(df[which(df$problemName == p),],ylog = T)
    print(graph)
}
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
